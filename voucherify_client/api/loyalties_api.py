# coding: utf-8

"""
    Voucherify API

    Voucherify promotion engine REST API. Please see https://docs.voucherify.io/docs for more details.

    The version of the OpenAPI document: v2018-08-01
    Contact: support@voucherify.io
    Generated by OpenAPI Generator (https://openapi-generator.tech)

    Do not edit the class manually.
"""  # noqa: E501


import re  # noqa: F401
import io
import warnings

from pydantic import validate_arguments, ValidationError

from typing_extensions import Annotated
from pydantic import Field, StrictBool, StrictStr, conint, conlist

from typing import List, Optional

from voucherify_client.models.loyalties_delete_response_body import LoyaltiesDeleteResponseBody
from voucherify_client.models.loyalties_earning_rules_disable_response_body import LoyaltiesEarningRulesDisableResponseBody
from voucherify_client.models.loyalties_earning_rules_enable_response_body import LoyaltiesEarningRulesEnableResponseBody
from voucherify_client.models.loyalties_earning_rules_get_response_body import LoyaltiesEarningRulesGetResponseBody
from voucherify_client.models.loyalties_members_balance_update_request_body import LoyaltiesMembersBalanceUpdateRequestBody
from voucherify_client.models.loyalties_members_balance_update_response_body import LoyaltiesMembersBalanceUpdateResponseBody
from voucherify_client.models.loyalties_members_points_expiration_list_response_body import LoyaltiesMembersPointsExpirationListResponseBody
from voucherify_client.models.loyalties_members_redemption_redeem_request_body import LoyaltiesMembersRedemptionRedeemRequestBody
from voucherify_client.models.loyalties_members_redemption_redeem_response_body import LoyaltiesMembersRedemptionRedeemResponseBody
from voucherify_client.models.loyalties_members_rewards_list_response_body import LoyaltiesMembersRewardsListResponseBody
from voucherify_client.models.loyalties_members_tiers_list_response_body import LoyaltiesMembersTiersListResponseBody
from voucherify_client.models.loyalties_members_transactions_export_create_request_body import LoyaltiesMembersTransactionsExportCreateRequestBody
from voucherify_client.models.loyalties_members_transactions_export_create_response_body import LoyaltiesMembersTransactionsExportCreateResponseBody
from voucherify_client.models.loyalties_members_transactions_list_response_body import LoyaltiesMembersTransactionsListResponseBody
from voucherify_client.models.loyalties_members_transfers_create_response_body import LoyaltiesMembersTransfersCreateResponseBody
from voucherify_client.models.loyalties_reward_assignments_get_response_body import LoyaltiesRewardAssignmentsGetResponseBody
from voucherify_client.models.loyalties_reward_assignments_reward_get_response_body import LoyaltiesRewardAssignmentsRewardGetResponseBody
from voucherify_client.models.loyalties_rewards_get_response_body import LoyaltiesRewardsGetResponseBody
from voucherify_client.models.loyalties_tiers_create_in_bulk_request_body_item import LoyaltiesTiersCreateInBulkRequestBodyItem
from voucherify_client.models.loyalties_tiers_earning_rules_list_response_body import LoyaltiesTiersEarningRulesListResponseBody
from voucherify_client.models.loyalties_tiers_get_response_body import LoyaltiesTiersGetResponseBody
from voucherify_client.models.loyalties_tiers_list_response_body import LoyaltiesTiersListResponseBody
from voucherify_client.models.loyalties_tiers_rewards_list_response_body import LoyaltiesTiersRewardsListResponseBody
from voucherify_client.models.loyalties_transfer_points import LoyaltiesTransferPoints
from voucherify_client.models.loyalty_tier import LoyaltyTier
from voucherify_client.models.parameter_order_list_loyalty_tiers import ParameterOrderListLoyaltyTiers

from voucherify_client.api_client import ApiClient
from voucherify_client.api_response import ApiResponse
from voucherify_client.exceptions import (  # noqa: F401
    ApiTypeError,
    ApiValueError
)


class LoyaltiesApi:
    """NOTE: This class is auto generated by OpenAPI Generator
    Ref: https://openapi-generator.tech

    Do not edit the class manually.
    """

    def __init__(self, api_client=None) -> None:
        if api_client is None:
            api_client = ApiClient.get_default()
        self.api_client = api_client

    @validate_arguments
    def create_in_bulk_loyalty_tiers(self, campaign_id : Annotated[StrictStr, Field(..., description="Unique loyalty campaign ID or name.")], loyalties_tiers_create_in_bulk_request_body_item : Annotated[Optional[conlist(LoyaltiesTiersCreateInBulkRequestBodyItem)], Field(description="Provide tier definitions you want to add to existing loyalty campaign.")] = None, **kwargs) -> List[LoyaltyTier]:  # noqa: E501
        """Create loyalty tiers  # noqa: E501

        Creates loyalty tiers for desired campaign.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.create_in_bulk_loyalty_tiers(campaign_id, loyalties_tiers_create_in_bulk_request_body_item, async_req=True)
        >>> result = thread.get()

        :param campaign_id: Unique loyalty campaign ID or name. (required)
        :type campaign_id: str
        :param loyalties_tiers_create_in_bulk_request_body_item: Provide tier definitions you want to add to existing loyalty campaign.
        :type loyalties_tiers_create_in_bulk_request_body_item: List[LoyaltiesTiersCreateInBulkRequestBodyItem]
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request.
               If one number provided, it will be total request
               timeout. It can also be a pair (tuple) of
               (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: List[LoyaltyTier]
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            message = "Error! Please call the create_in_bulk_loyalty_tiers_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"  # noqa: E501
            raise ValueError(message)
        return self.create_in_bulk_loyalty_tiers_with_http_info(campaign_id, loyalties_tiers_create_in_bulk_request_body_item, **kwargs)  # noqa: E501

    @validate_arguments
    def create_in_bulk_loyalty_tiers_with_http_info(self, campaign_id : Annotated[StrictStr, Field(..., description="Unique loyalty campaign ID or name.")], loyalties_tiers_create_in_bulk_request_body_item : Annotated[Optional[conlist(LoyaltiesTiersCreateInBulkRequestBodyItem)], Field(description="Provide tier definitions you want to add to existing loyalty campaign.")] = None, **kwargs) -> ApiResponse:  # noqa: E501
        """Create loyalty tiers  # noqa: E501

        Creates loyalty tiers for desired campaign.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.create_in_bulk_loyalty_tiers_with_http_info(campaign_id, loyalties_tiers_create_in_bulk_request_body_item, async_req=True)
        >>> result = thread.get()

        :param campaign_id: Unique loyalty campaign ID or name. (required)
        :type campaign_id: str
        :param loyalties_tiers_create_in_bulk_request_body_item: Provide tier definitions you want to add to existing loyalty campaign.
        :type loyalties_tiers_create_in_bulk_request_body_item: List[LoyaltiesTiersCreateInBulkRequestBodyItem]
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(List[LoyaltyTier], status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            'campaign_id',
            'loyalties_tiers_create_in_bulk_request_body_item'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method create_in_bulk_loyalty_tiers" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}
        if _params['campaign_id']:
            _path_params['campaignId'] = _params['campaign_id']


        # process the query parameters
        _query_params = []
        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        if _params['loyalties_tiers_create_in_bulk_request_body_item'] is not None:
            _body_params = _params['loyalties_tiers_create_in_bulk_request_body_item']

        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # set the HTTP header `Content-Type`
        _content_types_list = _params.get('_content_type',
            self.api_client.select_header_content_type(
                ['application/json']))
        if _content_types_list:
                _header_params['Content-Type'] = _content_types_list

        # authentication setting
        _auth_settings = ['X-App-Id', 'X-App-Token']  # noqa: E501

        _response_types_map = {
            '200': "List[LoyaltyTier]",
        }

        return self.api_client.call_api(
            '/v1/loyalties/{campaignId}/tiers', 'POST',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_arguments
    def delete_earning_rule(self, campaign_id : Annotated[StrictStr, Field(..., description="The campaign ID or name of the loyalty campaign. You can either pass the campaign ID, which was assigned by Voucherify, or the `name` of the campaign as the path parameter value, e.g., `Loyalty%20Campaign`. ")], earning_rule_id : Annotated[StrictStr, Field(..., description="A unique earning rule ID.")], **kwargs) -> None:  # noqa: E501
        """Delete Earning Rule  # noqa: E501

        This method deletes an earning rule for a specific loyalty campaign.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.delete_earning_rule(campaign_id, earning_rule_id, async_req=True)
        >>> result = thread.get()

        :param campaign_id: The campaign ID or name of the loyalty campaign. You can either pass the campaign ID, which was assigned by Voucherify, or the `name` of the campaign as the path parameter value, e.g., `Loyalty%20Campaign`.  (required)
        :type campaign_id: str
        :param earning_rule_id: A unique earning rule ID. (required)
        :type earning_rule_id: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request.
               If one number provided, it will be total request
               timeout. It can also be a pair (tuple) of
               (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: None
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            message = "Error! Please call the delete_earning_rule_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"  # noqa: E501
            raise ValueError(message)
        return self.delete_earning_rule_with_http_info(campaign_id, earning_rule_id, **kwargs)  # noqa: E501

    @validate_arguments
    def delete_earning_rule_with_http_info(self, campaign_id : Annotated[StrictStr, Field(..., description="The campaign ID or name of the loyalty campaign. You can either pass the campaign ID, which was assigned by Voucherify, or the `name` of the campaign as the path parameter value, e.g., `Loyalty%20Campaign`. ")], earning_rule_id : Annotated[StrictStr, Field(..., description="A unique earning rule ID.")], **kwargs) -> ApiResponse:  # noqa: E501
        """Delete Earning Rule  # noqa: E501

        This method deletes an earning rule for a specific loyalty campaign.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.delete_earning_rule_with_http_info(campaign_id, earning_rule_id, async_req=True)
        >>> result = thread.get()

        :param campaign_id: The campaign ID or name of the loyalty campaign. You can either pass the campaign ID, which was assigned by Voucherify, or the `name` of the campaign as the path parameter value, e.g., `Loyalty%20Campaign`.  (required)
        :type campaign_id: str
        :param earning_rule_id: A unique earning rule ID. (required)
        :type earning_rule_id: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: None
        """

        _params = locals()

        _all_params = [
            'campaign_id',
            'earning_rule_id'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method delete_earning_rule" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}
        if _params['campaign_id']:
            _path_params['campaignId'] = _params['campaign_id']

        if _params['earning_rule_id']:
            _path_params['earningRuleId'] = _params['earning_rule_id']


        # process the query parameters
        _query_params = []
        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        # authentication setting
        _auth_settings = ['X-App-Id', 'X-App-Token']  # noqa: E501

        _response_types_map = {}

        return self.api_client.call_api(
            '/v1/loyalties/{campaignId}/earning-rules/{earningRuleId}', 'DELETE',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_arguments
    def delete_loyalty_program(self, campaign_id : Annotated[StrictStr, Field(..., description="The campaign ID or name of the loyalty campaign. You can either pass the campaign ID, which was assigned by Voucherify, or the `name` of the campaign as the path parameter value, e.g., `Loyalty%20Campaign`. ")], force : Annotated[Optional[StrictBool], Field(description="If this flag is set to `true`, the campaign and related vouchers will be removed permanently. Going forward, the user will be able to create the next campaign with the same name.")] = None, **kwargs) -> LoyaltiesDeleteResponseBody:  # noqa: E501
        """Delete Loyalty Campaign  # noqa: E501

        This method permanently deletes a loyalty campaign and all related loyalty cards. This action cannot be undone. Also, it immediately removes any redemptions on loyalty cards.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.delete_loyalty_program(campaign_id, force, async_req=True)
        >>> result = thread.get()

        :param campaign_id: The campaign ID or name of the loyalty campaign. You can either pass the campaign ID, which was assigned by Voucherify, or the `name` of the campaign as the path parameter value, e.g., `Loyalty%20Campaign`.  (required)
        :type campaign_id: str
        :param force: If this flag is set to `true`, the campaign and related vouchers will be removed permanently. Going forward, the user will be able to create the next campaign with the same name.
        :type force: bool
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request.
               If one number provided, it will be total request
               timeout. It can also be a pair (tuple) of
               (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: LoyaltiesDeleteResponseBody
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            message = "Error! Please call the delete_loyalty_program_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"  # noqa: E501
            raise ValueError(message)
        return self.delete_loyalty_program_with_http_info(campaign_id, force, **kwargs)  # noqa: E501

    @validate_arguments
    def delete_loyalty_program_with_http_info(self, campaign_id : Annotated[StrictStr, Field(..., description="The campaign ID or name of the loyalty campaign. You can either pass the campaign ID, which was assigned by Voucherify, or the `name` of the campaign as the path parameter value, e.g., `Loyalty%20Campaign`. ")], force : Annotated[Optional[StrictBool], Field(description="If this flag is set to `true`, the campaign and related vouchers will be removed permanently. Going forward, the user will be able to create the next campaign with the same name.")] = None, **kwargs) -> ApiResponse:  # noqa: E501
        """Delete Loyalty Campaign  # noqa: E501

        This method permanently deletes a loyalty campaign and all related loyalty cards. This action cannot be undone. Also, it immediately removes any redemptions on loyalty cards.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.delete_loyalty_program_with_http_info(campaign_id, force, async_req=True)
        >>> result = thread.get()

        :param campaign_id: The campaign ID or name of the loyalty campaign. You can either pass the campaign ID, which was assigned by Voucherify, or the `name` of the campaign as the path parameter value, e.g., `Loyalty%20Campaign`.  (required)
        :type campaign_id: str
        :param force: If this flag is set to `true`, the campaign and related vouchers will be removed permanently. Going forward, the user will be able to create the next campaign with the same name.
        :type force: bool
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(LoyaltiesDeleteResponseBody, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            'campaign_id',
            'force'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method delete_loyalty_program" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}
        if _params['campaign_id']:
            _path_params['campaignId'] = _params['campaign_id']


        # process the query parameters
        _query_params = []
        if _params.get('force') is not None:  # noqa: E501
            _query_params.append(('force', _params['force']))

        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # authentication setting
        _auth_settings = ['X-App-Id', 'X-App-Token']  # noqa: E501

        _response_types_map = {
            '200': "LoyaltiesDeleteResponseBody",
        }

        return self.api_client.call_api(
            '/v1/loyalties/{campaignId}', 'DELETE',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_arguments
    def delete_reward_assignment1(self, campaign_id : Annotated[StrictStr, Field(..., description="The campaign ID or name of the loyalty campaign. You can either pass the campaign ID, which was assigned by Voucherify, or the `name` of the campaign as the path parameter value, e.g., `Loyalty%20Campaign`. ")], assignment_id : Annotated[StrictStr, Field(..., description="A unique reward assignment ID.")], **kwargs) -> None:  # noqa: E501
        """Delete Reward Assignment  # noqa: E501

        This method deletes a reward assignment for a particular loyalty campaign.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.delete_reward_assignment1(campaign_id, assignment_id, async_req=True)
        >>> result = thread.get()

        :param campaign_id: The campaign ID or name of the loyalty campaign. You can either pass the campaign ID, which was assigned by Voucherify, or the `name` of the campaign as the path parameter value, e.g., `Loyalty%20Campaign`.  (required)
        :type campaign_id: str
        :param assignment_id: A unique reward assignment ID. (required)
        :type assignment_id: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request.
               If one number provided, it will be total request
               timeout. It can also be a pair (tuple) of
               (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: None
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            message = "Error! Please call the delete_reward_assignment1_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"  # noqa: E501
            raise ValueError(message)
        return self.delete_reward_assignment1_with_http_info(campaign_id, assignment_id, **kwargs)  # noqa: E501

    @validate_arguments
    def delete_reward_assignment1_with_http_info(self, campaign_id : Annotated[StrictStr, Field(..., description="The campaign ID or name of the loyalty campaign. You can either pass the campaign ID, which was assigned by Voucherify, or the `name` of the campaign as the path parameter value, e.g., `Loyalty%20Campaign`. ")], assignment_id : Annotated[StrictStr, Field(..., description="A unique reward assignment ID.")], **kwargs) -> ApiResponse:  # noqa: E501
        """Delete Reward Assignment  # noqa: E501

        This method deletes a reward assignment for a particular loyalty campaign.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.delete_reward_assignment1_with_http_info(campaign_id, assignment_id, async_req=True)
        >>> result = thread.get()

        :param campaign_id: The campaign ID or name of the loyalty campaign. You can either pass the campaign ID, which was assigned by Voucherify, or the `name` of the campaign as the path parameter value, e.g., `Loyalty%20Campaign`.  (required)
        :type campaign_id: str
        :param assignment_id: A unique reward assignment ID. (required)
        :type assignment_id: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: None
        """

        _params = locals()

        _all_params = [
            'campaign_id',
            'assignment_id'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method delete_reward_assignment1" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}
        if _params['campaign_id']:
            _path_params['campaignId'] = _params['campaign_id']

        if _params['assignment_id']:
            _path_params['assignmentId'] = _params['assignment_id']


        # process the query parameters
        _query_params = []
        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        # authentication setting
        _auth_settings = ['X-App-Id', 'X-App-Token']  # noqa: E501

        _response_types_map = {}

        return self.api_client.call_api(
            '/v1/loyalties/{campaignId}/rewards/{assignmentId}', 'DELETE',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_arguments
    def disable_earning_rule(self, campaign_id : Annotated[StrictStr, Field(..., description="Unique campaign ID or name.")], earning_rule_id : Annotated[StrictStr, Field(..., description="Unique earning rule ID.")], **kwargs) -> LoyaltiesEarningRulesDisableResponseBody:  # noqa: E501
        """Disable Earning Rule  # noqa: E501

        Disable an earning rule.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.disable_earning_rule(campaign_id, earning_rule_id, async_req=True)
        >>> result = thread.get()

        :param campaign_id: Unique campaign ID or name. (required)
        :type campaign_id: str
        :param earning_rule_id: Unique earning rule ID. (required)
        :type earning_rule_id: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request.
               If one number provided, it will be total request
               timeout. It can also be a pair (tuple) of
               (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: LoyaltiesEarningRulesDisableResponseBody
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            message = "Error! Please call the disable_earning_rule_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"  # noqa: E501
            raise ValueError(message)
        return self.disable_earning_rule_with_http_info(campaign_id, earning_rule_id, **kwargs)  # noqa: E501

    @validate_arguments
    def disable_earning_rule_with_http_info(self, campaign_id : Annotated[StrictStr, Field(..., description="Unique campaign ID or name.")], earning_rule_id : Annotated[StrictStr, Field(..., description="Unique earning rule ID.")], **kwargs) -> ApiResponse:  # noqa: E501
        """Disable Earning Rule  # noqa: E501

        Disable an earning rule.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.disable_earning_rule_with_http_info(campaign_id, earning_rule_id, async_req=True)
        >>> result = thread.get()

        :param campaign_id: Unique campaign ID or name. (required)
        :type campaign_id: str
        :param earning_rule_id: Unique earning rule ID. (required)
        :type earning_rule_id: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(LoyaltiesEarningRulesDisableResponseBody, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            'campaign_id',
            'earning_rule_id'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method disable_earning_rule" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}
        if _params['campaign_id']:
            _path_params['campaignId'] = _params['campaign_id']

        if _params['earning_rule_id']:
            _path_params['earningRuleId'] = _params['earning_rule_id']


        # process the query parameters
        _query_params = []
        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # authentication setting
        _auth_settings = ['X-App-Id', 'X-App-Token']  # noqa: E501

        _response_types_map = {
            '200': "LoyaltiesEarningRulesDisableResponseBody",
        }

        return self.api_client.call_api(
            '/v1/loyalties/{campaignId}/earning-rules/{earningRuleId}/disable', 'POST',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_arguments
    def enable_earning_rule(self, campaign_id : Annotated[StrictStr, Field(..., description="Unique campaign ID or name.")], earning_rule_id : Annotated[StrictStr, Field(..., description="Unique earning rule ID.")], **kwargs) -> LoyaltiesEarningRulesEnableResponseBody:  # noqa: E501
        """Enable Earning Rule  # noqa: E501

        Enable an earning rule.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.enable_earning_rule(campaign_id, earning_rule_id, async_req=True)
        >>> result = thread.get()

        :param campaign_id: Unique campaign ID or name. (required)
        :type campaign_id: str
        :param earning_rule_id: Unique earning rule ID. (required)
        :type earning_rule_id: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request.
               If one number provided, it will be total request
               timeout. It can also be a pair (tuple) of
               (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: LoyaltiesEarningRulesEnableResponseBody
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            message = "Error! Please call the enable_earning_rule_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"  # noqa: E501
            raise ValueError(message)
        return self.enable_earning_rule_with_http_info(campaign_id, earning_rule_id, **kwargs)  # noqa: E501

    @validate_arguments
    def enable_earning_rule_with_http_info(self, campaign_id : Annotated[StrictStr, Field(..., description="Unique campaign ID or name.")], earning_rule_id : Annotated[StrictStr, Field(..., description="Unique earning rule ID.")], **kwargs) -> ApiResponse:  # noqa: E501
        """Enable Earning Rule  # noqa: E501

        Enable an earning rule.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.enable_earning_rule_with_http_info(campaign_id, earning_rule_id, async_req=True)
        >>> result = thread.get()

        :param campaign_id: Unique campaign ID or name. (required)
        :type campaign_id: str
        :param earning_rule_id: Unique earning rule ID. (required)
        :type earning_rule_id: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(LoyaltiesEarningRulesEnableResponseBody, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            'campaign_id',
            'earning_rule_id'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method enable_earning_rule" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}
        if _params['campaign_id']:
            _path_params['campaignId'] = _params['campaign_id']

        if _params['earning_rule_id']:
            _path_params['earningRuleId'] = _params['earning_rule_id']


        # process the query parameters
        _query_params = []
        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # authentication setting
        _auth_settings = ['X-App-Id', 'X-App-Token']  # noqa: E501

        _response_types_map = {
            '200': "LoyaltiesEarningRulesEnableResponseBody",
        }

        return self.api_client.call_api(
            '/v1/loyalties/{campaignId}/earning-rules/{earningRuleId}/enable', 'POST',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_arguments
    def export_loyalty_card_transactions(self, member_id : Annotated[StrictStr, Field(..., description="A unique code identifying the loyalty card that you are looking to export transaction data for.")], loyalties_members_transactions_export_create_request_body : Annotated[Optional[LoyaltiesMembersTransactionsExportCreateRequestBody], Field(description="Specify the parameters and filters for the transaction export.")] = None, **kwargs) -> LoyaltiesMembersTransactionsExportCreateResponseBody:  # noqa: E501
        """Export Loyalty Card Transactions  # noqa: E501

        Export transactions that are associated with point movements on a loyalty card.  | **Field** | **Definition** | **Example Export** | |:---|:---|:---| | id | Unique transaction ID assigned by Voucherify. | vtx_0cb7811f1c07765800 | | type | Transaction type. | - `POINTS_EXPIRATION` <br> - `POINTS_ADDITION` <br> - `POINTS_REMOVAL` <br> - `POINTS_TRANSFER_OUT` <br> - `POINTS_ACCRUAL` <br> - `POINTS_REFUND` <br> - `POINTS_REDEMPTION` | | source_id | Custom source ID of the transaction if one was included originally. | source_id_custom | | reason | Contains the reason for the transaction if one was included originally. |  | | balance | The loyalty card balance after the transaction. |  | | amount | The amount of loyalty points being allocated during the transaction. This value can either be negative or positive depending on the nature of the transaction. |  | | created_at | Timestamp in ISO 8601 format representing the date and time when the transaction was created. | 2022-03-09T09:16:32.521Z  | | voucher_id | Unique Voucher ID. | v_dky7ksKfPX50Wb2Bxvcoeb1xT20b6tcp | | campaign_id | Parent campaign ID. | camp_FNYR4jhqZBM9xTptxDGgeNBV | | source|  Channel through which the transaction was initiated. | - `API` <br> - `voucherify-web-ui` <br> - `Automation` | | details | More detailed information stored in the form of a JSON. | Provides more details related to the transaction in the form of an object. | | related_transaction_id | Unique transaction ID related to a receiver/donor card in the case of a points transfer from/to another card. | vtx_0c9afe802593b34b80 |  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.export_loyalty_card_transactions(member_id, loyalties_members_transactions_export_create_request_body, async_req=True)
        >>> result = thread.get()

        :param member_id: A unique code identifying the loyalty card that you are looking to export transaction data for. (required)
        :type member_id: str
        :param loyalties_members_transactions_export_create_request_body: Specify the parameters and filters for the transaction export.
        :type loyalties_members_transactions_export_create_request_body: LoyaltiesMembersTransactionsExportCreateRequestBody
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request.
               If one number provided, it will be total request
               timeout. It can also be a pair (tuple) of
               (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: LoyaltiesMembersTransactionsExportCreateResponseBody
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            message = "Error! Please call the export_loyalty_card_transactions_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"  # noqa: E501
            raise ValueError(message)
        return self.export_loyalty_card_transactions_with_http_info(member_id, loyalties_members_transactions_export_create_request_body, **kwargs)  # noqa: E501

    @validate_arguments
    def export_loyalty_card_transactions_with_http_info(self, member_id : Annotated[StrictStr, Field(..., description="A unique code identifying the loyalty card that you are looking to export transaction data for.")], loyalties_members_transactions_export_create_request_body : Annotated[Optional[LoyaltiesMembersTransactionsExportCreateRequestBody], Field(description="Specify the parameters and filters for the transaction export.")] = None, **kwargs) -> ApiResponse:  # noqa: E501
        """Export Loyalty Card Transactions  # noqa: E501

        Export transactions that are associated with point movements on a loyalty card.  | **Field** | **Definition** | **Example Export** | |:---|:---|:---| | id | Unique transaction ID assigned by Voucherify. | vtx_0cb7811f1c07765800 | | type | Transaction type. | - `POINTS_EXPIRATION` <br> - `POINTS_ADDITION` <br> - `POINTS_REMOVAL` <br> - `POINTS_TRANSFER_OUT` <br> - `POINTS_ACCRUAL` <br> - `POINTS_REFUND` <br> - `POINTS_REDEMPTION` | | source_id | Custom source ID of the transaction if one was included originally. | source_id_custom | | reason | Contains the reason for the transaction if one was included originally. |  | | balance | The loyalty card balance after the transaction. |  | | amount | The amount of loyalty points being allocated during the transaction. This value can either be negative or positive depending on the nature of the transaction. |  | | created_at | Timestamp in ISO 8601 format representing the date and time when the transaction was created. | 2022-03-09T09:16:32.521Z  | | voucher_id | Unique Voucher ID. | v_dky7ksKfPX50Wb2Bxvcoeb1xT20b6tcp | | campaign_id | Parent campaign ID. | camp_FNYR4jhqZBM9xTptxDGgeNBV | | source|  Channel through which the transaction was initiated. | - `API` <br> - `voucherify-web-ui` <br> - `Automation` | | details | More detailed information stored in the form of a JSON. | Provides more details related to the transaction in the form of an object. | | related_transaction_id | Unique transaction ID related to a receiver/donor card in the case of a points transfer from/to another card. | vtx_0c9afe802593b34b80 |  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.export_loyalty_card_transactions_with_http_info(member_id, loyalties_members_transactions_export_create_request_body, async_req=True)
        >>> result = thread.get()

        :param member_id: A unique code identifying the loyalty card that you are looking to export transaction data for. (required)
        :type member_id: str
        :param loyalties_members_transactions_export_create_request_body: Specify the parameters and filters for the transaction export.
        :type loyalties_members_transactions_export_create_request_body: LoyaltiesMembersTransactionsExportCreateRequestBody
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(LoyaltiesMembersTransactionsExportCreateResponseBody, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            'member_id',
            'loyalties_members_transactions_export_create_request_body'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method export_loyalty_card_transactions" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}
        if _params['member_id']:
            _path_params['memberId'] = _params['member_id']


        # process the query parameters
        _query_params = []
        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        if _params['loyalties_members_transactions_export_create_request_body'] is not None:
            _body_params = _params['loyalties_members_transactions_export_create_request_body']

        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # set the HTTP header `Content-Type`
        _content_types_list = _params.get('_content_type',
            self.api_client.select_header_content_type(
                ['application/json']))
        if _content_types_list:
                _header_params['Content-Type'] = _content_types_list

        # authentication setting
        _auth_settings = ['X-App-Id', 'X-App-Token']  # noqa: E501

        _response_types_map = {
            '200': "LoyaltiesMembersTransactionsExportCreateResponseBody",
        }

        return self.api_client.call_api(
            '/v1/loyalties/members/{memberId}/transactions/export', 'POST',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_arguments
    def export_loyalty_card_transactions1(self, campaign_id : Annotated[StrictStr, Field(..., description="A unique identifier of the loyalty campaign containing the voucher whose transactions you would like to export.")], member_id : Annotated[StrictStr, Field(..., description="A unique code identifying the loyalty card that you are looking to export transaction data for.")], loyalties_members_transactions_export_create_request_body : Annotated[Optional[LoyaltiesMembersTransactionsExportCreateRequestBody], Field(description="Specify the parameters and filters for the transaction export.")] = None, **kwargs) -> LoyaltiesMembersTransactionsExportCreateResponseBody:  # noqa: E501
        """Export Loyalty Card Transactions  # noqa: E501

        Export transactions that are associated with point movements on a loyalty card.  | **Field** | **Definition** | **Example Export** | |:---|:---|:---| | id | Unique transaction ID assigned by Voucherify. | vtx_0cb7811f1c07765800 | | type | Transaction type. | - `POINTS_EXPIRATION` <br> - `POINTS_ADDITION` <br> - `POINTS_REMOVAL` <br> - `POINTS_TRANSFER_OUT` <br> - `POINTS_ACCRUAL` <br> - `POINTS_REFUND` <br> - `POINTS_REDEMPTION` | | source_id | Custom source ID of the transaction if one was included originally. | source_id_custom | | reason | Contains the reason for the transaction if one was included originally. |  | | balance | The loyalty card balance after the transaction. |  | | amount | The amount of loyalty points being allocated during the transaction. This value can either be negative or positive depending on the nature of the transaction. |  | | created_at | Timestamp in ISO 8601 format representing the date and time when the transaction was created. | 2022-03-09T09:16:32.521Z  | | voucher_id | Unique Voucher ID. | v_dky7ksKfPX50Wb2Bxvcoeb1xT20b6tcp | | campaign_id | Parent campaign ID. | camp_FNYR4jhqZBM9xTptxDGgeNBV | | source|  Channel through which the transaction was initiated. | - `API` <br> - `voucherify-web-ui` <br> - `Automation` | | details | More detailed information stored in the form of a JSON. | Provides more details related to the transaction in the form of an object. | | related_transaction_id | Unique transaction ID related to a receiver/donor card in the case of a points transfer from/to another card. | vtx_0c9afe802593b34b80 |  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.export_loyalty_card_transactions1(campaign_id, member_id, loyalties_members_transactions_export_create_request_body, async_req=True)
        >>> result = thread.get()

        :param campaign_id: A unique identifier of the loyalty campaign containing the voucher whose transactions you would like to export. (required)
        :type campaign_id: str
        :param member_id: A unique code identifying the loyalty card that you are looking to export transaction data for. (required)
        :type member_id: str
        :param loyalties_members_transactions_export_create_request_body: Specify the parameters and filters for the transaction export.
        :type loyalties_members_transactions_export_create_request_body: LoyaltiesMembersTransactionsExportCreateRequestBody
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request.
               If one number provided, it will be total request
               timeout. It can also be a pair (tuple) of
               (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: LoyaltiesMembersTransactionsExportCreateResponseBody
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            message = "Error! Please call the export_loyalty_card_transactions1_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"  # noqa: E501
            raise ValueError(message)
        return self.export_loyalty_card_transactions1_with_http_info(campaign_id, member_id, loyalties_members_transactions_export_create_request_body, **kwargs)  # noqa: E501

    @validate_arguments
    def export_loyalty_card_transactions1_with_http_info(self, campaign_id : Annotated[StrictStr, Field(..., description="A unique identifier of the loyalty campaign containing the voucher whose transactions you would like to export.")], member_id : Annotated[StrictStr, Field(..., description="A unique code identifying the loyalty card that you are looking to export transaction data for.")], loyalties_members_transactions_export_create_request_body : Annotated[Optional[LoyaltiesMembersTransactionsExportCreateRequestBody], Field(description="Specify the parameters and filters for the transaction export.")] = None, **kwargs) -> ApiResponse:  # noqa: E501
        """Export Loyalty Card Transactions  # noqa: E501

        Export transactions that are associated with point movements on a loyalty card.  | **Field** | **Definition** | **Example Export** | |:---|:---|:---| | id | Unique transaction ID assigned by Voucherify. | vtx_0cb7811f1c07765800 | | type | Transaction type. | - `POINTS_EXPIRATION` <br> - `POINTS_ADDITION` <br> - `POINTS_REMOVAL` <br> - `POINTS_TRANSFER_OUT` <br> - `POINTS_ACCRUAL` <br> - `POINTS_REFUND` <br> - `POINTS_REDEMPTION` | | source_id | Custom source ID of the transaction if one was included originally. | source_id_custom | | reason | Contains the reason for the transaction if one was included originally. |  | | balance | The loyalty card balance after the transaction. |  | | amount | The amount of loyalty points being allocated during the transaction. This value can either be negative or positive depending on the nature of the transaction. |  | | created_at | Timestamp in ISO 8601 format representing the date and time when the transaction was created. | 2022-03-09T09:16:32.521Z  | | voucher_id | Unique Voucher ID. | v_dky7ksKfPX50Wb2Bxvcoeb1xT20b6tcp | | campaign_id | Parent campaign ID. | camp_FNYR4jhqZBM9xTptxDGgeNBV | | source|  Channel through which the transaction was initiated. | - `API` <br> - `voucherify-web-ui` <br> - `Automation` | | details | More detailed information stored in the form of a JSON. | Provides more details related to the transaction in the form of an object. | | related_transaction_id | Unique transaction ID related to a receiver/donor card in the case of a points transfer from/to another card. | vtx_0c9afe802593b34b80 |  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.export_loyalty_card_transactions1_with_http_info(campaign_id, member_id, loyalties_members_transactions_export_create_request_body, async_req=True)
        >>> result = thread.get()

        :param campaign_id: A unique identifier of the loyalty campaign containing the voucher whose transactions you would like to export. (required)
        :type campaign_id: str
        :param member_id: A unique code identifying the loyalty card that you are looking to export transaction data for. (required)
        :type member_id: str
        :param loyalties_members_transactions_export_create_request_body: Specify the parameters and filters for the transaction export.
        :type loyalties_members_transactions_export_create_request_body: LoyaltiesMembersTransactionsExportCreateRequestBody
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(LoyaltiesMembersTransactionsExportCreateResponseBody, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            'campaign_id',
            'member_id',
            'loyalties_members_transactions_export_create_request_body'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method export_loyalty_card_transactions1" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}
        if _params['campaign_id']:
            _path_params['campaignId'] = _params['campaign_id']

        if _params['member_id']:
            _path_params['memberId'] = _params['member_id']


        # process the query parameters
        _query_params = []
        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        if _params['loyalties_members_transactions_export_create_request_body'] is not None:
            _body_params = _params['loyalties_members_transactions_export_create_request_body']

        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # set the HTTP header `Content-Type`
        _content_types_list = _params.get('_content_type',
            self.api_client.select_header_content_type(
                ['application/json']))
        if _content_types_list:
                _header_params['Content-Type'] = _content_types_list

        # authentication setting
        _auth_settings = ['X-App-Id', 'X-App-Token']  # noqa: E501

        _response_types_map = {
            '200': "LoyaltiesMembersTransactionsExportCreateResponseBody",
        }

        return self.api_client.call_api(
            '/v1/loyalties/{campaignId}/members/{memberId}/transactions/export', 'POST',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_arguments
    def get_earning_rule(self, campaign_id : Annotated[StrictStr, Field(..., description="The campaign ID or name of the loyalty campaign. You can either pass the campaign ID, which was assigned by Voucherify, or the `name` of the campaign as the path parameter value, e.g., `Loyalty%20Campaign`. ")], earning_rule_id : Annotated[StrictStr, Field(..., description="A unique earning rule ID.")], **kwargs) -> LoyaltiesEarningRulesGetResponseBody:  # noqa: E501
        """Get Earning Rule  # noqa: E501

        Retrieves an earning rule assigned to a campaign.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.get_earning_rule(campaign_id, earning_rule_id, async_req=True)
        >>> result = thread.get()

        :param campaign_id: The campaign ID or name of the loyalty campaign. You can either pass the campaign ID, which was assigned by Voucherify, or the `name` of the campaign as the path parameter value, e.g., `Loyalty%20Campaign`.  (required)
        :type campaign_id: str
        :param earning_rule_id: A unique earning rule ID. (required)
        :type earning_rule_id: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request.
               If one number provided, it will be total request
               timeout. It can also be a pair (tuple) of
               (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: LoyaltiesEarningRulesGetResponseBody
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            message = "Error! Please call the get_earning_rule_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"  # noqa: E501
            raise ValueError(message)
        return self.get_earning_rule_with_http_info(campaign_id, earning_rule_id, **kwargs)  # noqa: E501

    @validate_arguments
    def get_earning_rule_with_http_info(self, campaign_id : Annotated[StrictStr, Field(..., description="The campaign ID or name of the loyalty campaign. You can either pass the campaign ID, which was assigned by Voucherify, or the `name` of the campaign as the path parameter value, e.g., `Loyalty%20Campaign`. ")], earning_rule_id : Annotated[StrictStr, Field(..., description="A unique earning rule ID.")], **kwargs) -> ApiResponse:  # noqa: E501
        """Get Earning Rule  # noqa: E501

        Retrieves an earning rule assigned to a campaign.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.get_earning_rule_with_http_info(campaign_id, earning_rule_id, async_req=True)
        >>> result = thread.get()

        :param campaign_id: The campaign ID or name of the loyalty campaign. You can either pass the campaign ID, which was assigned by Voucherify, or the `name` of the campaign as the path parameter value, e.g., `Loyalty%20Campaign`.  (required)
        :type campaign_id: str
        :param earning_rule_id: A unique earning rule ID. (required)
        :type earning_rule_id: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(LoyaltiesEarningRulesGetResponseBody, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            'campaign_id',
            'earning_rule_id'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_earning_rule" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}
        if _params['campaign_id']:
            _path_params['campaignId'] = _params['campaign_id']

        if _params['earning_rule_id']:
            _path_params['earningRuleId'] = _params['earning_rule_id']


        # process the query parameters
        _query_params = []
        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # authentication setting
        _auth_settings = ['X-App-Id', 'X-App-Token']  # noqa: E501

        _response_types_map = {
            '200': "LoyaltiesEarningRulesGetResponseBody",
        }

        return self.api_client.call_api(
            '/v1/loyalties/{campaignId}/earning-rules/{earningRuleId}', 'GET',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_arguments
    def get_loyalty_tier(self, campaign_id : Annotated[StrictStr, Field(..., description="Unique loyalty campaign ID or name.")], loyalty_tier_id : Annotated[StrictStr, Field(..., description="Unique loyalty tier ID.")], **kwargs) -> LoyaltiesTiersGetResponseBody:  # noqa: E501
        """Get Loyalty Tier  # noqa: E501

        Retrieve a loyalty tier from a loyalty campaign by the loyalty tier ID.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.get_loyalty_tier(campaign_id, loyalty_tier_id, async_req=True)
        >>> result = thread.get()

        :param campaign_id: Unique loyalty campaign ID or name. (required)
        :type campaign_id: str
        :param loyalty_tier_id: Unique loyalty tier ID. (required)
        :type loyalty_tier_id: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request.
               If one number provided, it will be total request
               timeout. It can also be a pair (tuple) of
               (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: LoyaltiesTiersGetResponseBody
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            message = "Error! Please call the get_loyalty_tier_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"  # noqa: E501
            raise ValueError(message)
        return self.get_loyalty_tier_with_http_info(campaign_id, loyalty_tier_id, **kwargs)  # noqa: E501

    @validate_arguments
    def get_loyalty_tier_with_http_info(self, campaign_id : Annotated[StrictStr, Field(..., description="Unique loyalty campaign ID or name.")], loyalty_tier_id : Annotated[StrictStr, Field(..., description="Unique loyalty tier ID.")], **kwargs) -> ApiResponse:  # noqa: E501
        """Get Loyalty Tier  # noqa: E501

        Retrieve a loyalty tier from a loyalty campaign by the loyalty tier ID.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.get_loyalty_tier_with_http_info(campaign_id, loyalty_tier_id, async_req=True)
        >>> result = thread.get()

        :param campaign_id: Unique loyalty campaign ID or name. (required)
        :type campaign_id: str
        :param loyalty_tier_id: Unique loyalty tier ID. (required)
        :type loyalty_tier_id: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(LoyaltiesTiersGetResponseBody, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            'campaign_id',
            'loyalty_tier_id'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_loyalty_tier" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}
        if _params['campaign_id']:
            _path_params['campaignId'] = _params['campaign_id']

        if _params['loyalty_tier_id']:
            _path_params['loyaltyTierId'] = _params['loyalty_tier_id']


        # process the query parameters
        _query_params = []
        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # authentication setting
        _auth_settings = ['X-App-Id', 'X-App-Token']  # noqa: E501

        _response_types_map = {
            '200': "LoyaltiesTiersGetResponseBody",
        }

        return self.api_client.call_api(
            '/v1/loyalties/{campaignId}/tiers/{loyaltyTierId}', 'GET',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_arguments
    def get_reward_assignment1(self, campaign_id : Annotated[StrictStr, Field(..., description="The campaign ID or name of the loyalty campaign. You can either pass the campaign ID, which was assigned by Voucherify, or the `name` of the campaign as the path parameter value, e.g., `Loyalty%20Campaign`. ")], assignment_id : Annotated[StrictStr, Field(..., description="Unique reward assignment ID.")], **kwargs) -> LoyaltiesRewardAssignmentsGetResponseBody:  # noqa: E501
        """Get Reward Assignment  # noqa: E501

        Retrieve specific reward assignment.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.get_reward_assignment1(campaign_id, assignment_id, async_req=True)
        >>> result = thread.get()

        :param campaign_id: The campaign ID or name of the loyalty campaign. You can either pass the campaign ID, which was assigned by Voucherify, or the `name` of the campaign as the path parameter value, e.g., `Loyalty%20Campaign`.  (required)
        :type campaign_id: str
        :param assignment_id: Unique reward assignment ID. (required)
        :type assignment_id: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request.
               If one number provided, it will be total request
               timeout. It can also be a pair (tuple) of
               (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: LoyaltiesRewardAssignmentsGetResponseBody
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            message = "Error! Please call the get_reward_assignment1_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"  # noqa: E501
            raise ValueError(message)
        return self.get_reward_assignment1_with_http_info(campaign_id, assignment_id, **kwargs)  # noqa: E501

    @validate_arguments
    def get_reward_assignment1_with_http_info(self, campaign_id : Annotated[StrictStr, Field(..., description="The campaign ID or name of the loyalty campaign. You can either pass the campaign ID, which was assigned by Voucherify, or the `name` of the campaign as the path parameter value, e.g., `Loyalty%20Campaign`. ")], assignment_id : Annotated[StrictStr, Field(..., description="Unique reward assignment ID.")], **kwargs) -> ApiResponse:  # noqa: E501
        """Get Reward Assignment  # noqa: E501

        Retrieve specific reward assignment.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.get_reward_assignment1_with_http_info(campaign_id, assignment_id, async_req=True)
        >>> result = thread.get()

        :param campaign_id: The campaign ID or name of the loyalty campaign. You can either pass the campaign ID, which was assigned by Voucherify, or the `name` of the campaign as the path parameter value, e.g., `Loyalty%20Campaign`.  (required)
        :type campaign_id: str
        :param assignment_id: Unique reward assignment ID. (required)
        :type assignment_id: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(LoyaltiesRewardAssignmentsGetResponseBody, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            'campaign_id',
            'assignment_id'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_reward_assignment1" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}
        if _params['campaign_id']:
            _path_params['campaignId'] = _params['campaign_id']

        if _params['assignment_id']:
            _path_params['assignmentId'] = _params['assignment_id']


        # process the query parameters
        _query_params = []
        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # authentication setting
        _auth_settings = ['X-App-Id', 'X-App-Token']  # noqa: E501

        _response_types_map = {
            '200': "LoyaltiesRewardAssignmentsGetResponseBody",
        }

        return self.api_client.call_api(
            '/v1/loyalties/{campaignId}/reward-assignments/{assignmentId}', 'GET',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_arguments
    def get_reward_assignment2(self, campaign_id : Annotated[StrictStr, Field(..., description="The campaign ID or name of the loyalty campaign. You can either pass the campaign ID, which was assigned by Voucherify, or the `name` of the campaign as the path parameter value, e.g., `Loyalty%20Campaign`. ")], assignment_id : Annotated[StrictStr, Field(..., description="A unique reward assignment ID.")], **kwargs) -> LoyaltiesRewardsGetResponseBody:  # noqa: E501
        """Get Reward Assignment  # noqa: E501

        Retrieve specific reward assignment.  > 📘 Alternative endpoint > > This endpoint is an alternative to this [endpoint](ref:get-reward-assignment-2).   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.get_reward_assignment2(campaign_id, assignment_id, async_req=True)
        >>> result = thread.get()

        :param campaign_id: The campaign ID or name of the loyalty campaign. You can either pass the campaign ID, which was assigned by Voucherify, or the `name` of the campaign as the path parameter value, e.g., `Loyalty%20Campaign`.  (required)
        :type campaign_id: str
        :param assignment_id: A unique reward assignment ID. (required)
        :type assignment_id: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request.
               If one number provided, it will be total request
               timeout. It can also be a pair (tuple) of
               (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: LoyaltiesRewardsGetResponseBody
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            message = "Error! Please call the get_reward_assignment2_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"  # noqa: E501
            raise ValueError(message)
        return self.get_reward_assignment2_with_http_info(campaign_id, assignment_id, **kwargs)  # noqa: E501

    @validate_arguments
    def get_reward_assignment2_with_http_info(self, campaign_id : Annotated[StrictStr, Field(..., description="The campaign ID or name of the loyalty campaign. You can either pass the campaign ID, which was assigned by Voucherify, or the `name` of the campaign as the path parameter value, e.g., `Loyalty%20Campaign`. ")], assignment_id : Annotated[StrictStr, Field(..., description="A unique reward assignment ID.")], **kwargs) -> ApiResponse:  # noqa: E501
        """Get Reward Assignment  # noqa: E501

        Retrieve specific reward assignment.  > 📘 Alternative endpoint > > This endpoint is an alternative to this [endpoint](ref:get-reward-assignment-2).   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.get_reward_assignment2_with_http_info(campaign_id, assignment_id, async_req=True)
        >>> result = thread.get()

        :param campaign_id: The campaign ID or name of the loyalty campaign. You can either pass the campaign ID, which was assigned by Voucherify, or the `name` of the campaign as the path parameter value, e.g., `Loyalty%20Campaign`.  (required)
        :type campaign_id: str
        :param assignment_id: A unique reward assignment ID. (required)
        :type assignment_id: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(LoyaltiesRewardsGetResponseBody, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            'campaign_id',
            'assignment_id'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_reward_assignment2" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}
        if _params['campaign_id']:
            _path_params['campaignId'] = _params['campaign_id']

        if _params['assignment_id']:
            _path_params['assignmentId'] = _params['assignment_id']


        # process the query parameters
        _query_params = []
        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # authentication setting
        _auth_settings = ['X-App-Id', 'X-App-Token']  # noqa: E501

        _response_types_map = {
            '200': "LoyaltiesRewardsGetResponseBody",
        }

        return self.api_client.call_api(
            '/v1/loyalties/{campaignId}/rewards/{assignmentId}', 'GET',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_arguments
    def get_reward_details(self, campaign_id : Annotated[StrictStr, Field(..., description="The campaign ID or name of the loyalty campaign. You can either pass the campaign ID, which was assigned by Voucherify, or the `name` of the campaign as the path parameter value, e.g., `Loyalty%20Campaign`. ")], assignment_id : Annotated[StrictStr, Field(..., description="Unique reward assignment ID.")], **kwargs) -> LoyaltiesRewardAssignmentsRewardGetResponseBody:  # noqa: E501
        """Get Reward Details  # noqa: E501

        Get reward details in the context of a loyalty campaign and reward assignment ID.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.get_reward_details(campaign_id, assignment_id, async_req=True)
        >>> result = thread.get()

        :param campaign_id: The campaign ID or name of the loyalty campaign. You can either pass the campaign ID, which was assigned by Voucherify, or the `name` of the campaign as the path parameter value, e.g., `Loyalty%20Campaign`.  (required)
        :type campaign_id: str
        :param assignment_id: Unique reward assignment ID. (required)
        :type assignment_id: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request.
               If one number provided, it will be total request
               timeout. It can also be a pair (tuple) of
               (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: LoyaltiesRewardAssignmentsRewardGetResponseBody
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            message = "Error! Please call the get_reward_details_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"  # noqa: E501
            raise ValueError(message)
        return self.get_reward_details_with_http_info(campaign_id, assignment_id, **kwargs)  # noqa: E501

    @validate_arguments
    def get_reward_details_with_http_info(self, campaign_id : Annotated[StrictStr, Field(..., description="The campaign ID or name of the loyalty campaign. You can either pass the campaign ID, which was assigned by Voucherify, or the `name` of the campaign as the path parameter value, e.g., `Loyalty%20Campaign`. ")], assignment_id : Annotated[StrictStr, Field(..., description="Unique reward assignment ID.")], **kwargs) -> ApiResponse:  # noqa: E501
        """Get Reward Details  # noqa: E501

        Get reward details in the context of a loyalty campaign and reward assignment ID.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.get_reward_details_with_http_info(campaign_id, assignment_id, async_req=True)
        >>> result = thread.get()

        :param campaign_id: The campaign ID or name of the loyalty campaign. You can either pass the campaign ID, which was assigned by Voucherify, or the `name` of the campaign as the path parameter value, e.g., `Loyalty%20Campaign`.  (required)
        :type campaign_id: str
        :param assignment_id: Unique reward assignment ID. (required)
        :type assignment_id: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(LoyaltiesRewardAssignmentsRewardGetResponseBody, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            'campaign_id',
            'assignment_id'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_reward_details" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}
        if _params['campaign_id']:
            _path_params['campaignId'] = _params['campaign_id']

        if _params['assignment_id']:
            _path_params['assignmentId'] = _params['assignment_id']


        # process the query parameters
        _query_params = []
        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # authentication setting
        _auth_settings = ['X-App-Id', 'X-App-Token']  # noqa: E501

        _response_types_map = {
            '200': "LoyaltiesRewardAssignmentsRewardGetResponseBody",
        }

        return self.api_client.call_api(
            '/v1/loyalties/{campaignId}/reward-assignments/{assignmentId}/reward', 'GET',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_arguments
    def list_loyalty_card_transactions(self, member_id : Annotated[StrictStr, Field(..., description="A unique code identifying the loyalty card that you are looking to retrieve transaction data for.")], limit : Annotated[Optional[conint(strict=True, le=100, ge=1)], Field(description="A limit on the number of objects to be returned. Limit can range between 1 and 100 items.")] = None, page : Annotated[Optional[conint(strict=True, le=100)], Field(description="Which page of results to return.")] = None, **kwargs) -> LoyaltiesMembersTransactionsListResponseBody:  # noqa: E501
        """List Loyalty Card Transactions  # noqa: E501

        Retrieve transaction data related to point movements for a specific loyalty card.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.list_loyalty_card_transactions(member_id, limit, page, async_req=True)
        >>> result = thread.get()

        :param member_id: A unique code identifying the loyalty card that you are looking to retrieve transaction data for. (required)
        :type member_id: str
        :param limit: A limit on the number of objects to be returned. Limit can range between 1 and 100 items.
        :type limit: int
        :param page: Which page of results to return.
        :type page: int
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request.
               If one number provided, it will be total request
               timeout. It can also be a pair (tuple) of
               (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: LoyaltiesMembersTransactionsListResponseBody
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            message = "Error! Please call the list_loyalty_card_transactions_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"  # noqa: E501
            raise ValueError(message)
        return self.list_loyalty_card_transactions_with_http_info(member_id, limit, page, **kwargs)  # noqa: E501

    @validate_arguments
    def list_loyalty_card_transactions_with_http_info(self, member_id : Annotated[StrictStr, Field(..., description="A unique code identifying the loyalty card that you are looking to retrieve transaction data for.")], limit : Annotated[Optional[conint(strict=True, le=100, ge=1)], Field(description="A limit on the number of objects to be returned. Limit can range between 1 and 100 items.")] = None, page : Annotated[Optional[conint(strict=True, le=100)], Field(description="Which page of results to return.")] = None, **kwargs) -> ApiResponse:  # noqa: E501
        """List Loyalty Card Transactions  # noqa: E501

        Retrieve transaction data related to point movements for a specific loyalty card.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.list_loyalty_card_transactions_with_http_info(member_id, limit, page, async_req=True)
        >>> result = thread.get()

        :param member_id: A unique code identifying the loyalty card that you are looking to retrieve transaction data for. (required)
        :type member_id: str
        :param limit: A limit on the number of objects to be returned. Limit can range between 1 and 100 items.
        :type limit: int
        :param page: Which page of results to return.
        :type page: int
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(LoyaltiesMembersTransactionsListResponseBody, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            'member_id',
            'limit',
            'page'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method list_loyalty_card_transactions" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}
        if _params['member_id']:
            _path_params['memberId'] = _params['member_id']


        # process the query parameters
        _query_params = []
        if _params.get('limit') is not None:  # noqa: E501
            _query_params.append(('limit', _params['limit']))

        if _params.get('page') is not None:  # noqa: E501
            _query_params.append(('page', _params['page']))

        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # authentication setting
        _auth_settings = ['X-App-Id', 'X-App-Token']  # noqa: E501

        _response_types_map = {
            '200': "LoyaltiesMembersTransactionsListResponseBody",
        }

        return self.api_client.call_api(
            '/v1/loyalties/members/{memberId}/transactions', 'GET',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_arguments
    def list_loyalty_card_transactions1(self, campaign_id : Annotated[StrictStr, Field(..., description="A unique identifier of the loyalty campaign containing the voucher whose transactions you would like to return.")], member_id : Annotated[StrictStr, Field(..., description="A unique code identifying the loyalty card that you are looking to retrieve transaction data for.")], limit : Annotated[Optional[conint(strict=True, le=100, ge=1)], Field(description="A limit on the number of objects to be returned. Limit can range between 1 and 100 items.")] = None, page : Annotated[Optional[conint(strict=True, le=100)], Field(description="Which page of results to return.")] = None, **kwargs) -> LoyaltiesMembersTransactionsListResponseBody:  # noqa: E501
        """List Loyalty Card Transactions  # noqa: E501

        Retrieve transaction data related to point movements for a specific loyalty card.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.list_loyalty_card_transactions1(campaign_id, member_id, limit, page, async_req=True)
        >>> result = thread.get()

        :param campaign_id: A unique identifier of the loyalty campaign containing the voucher whose transactions you would like to return. (required)
        :type campaign_id: str
        :param member_id: A unique code identifying the loyalty card that you are looking to retrieve transaction data for. (required)
        :type member_id: str
        :param limit: A limit on the number of objects to be returned. Limit can range between 1 and 100 items.
        :type limit: int
        :param page: Which page of results to return.
        :type page: int
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request.
               If one number provided, it will be total request
               timeout. It can also be a pair (tuple) of
               (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: LoyaltiesMembersTransactionsListResponseBody
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            message = "Error! Please call the list_loyalty_card_transactions1_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"  # noqa: E501
            raise ValueError(message)
        return self.list_loyalty_card_transactions1_with_http_info(campaign_id, member_id, limit, page, **kwargs)  # noqa: E501

    @validate_arguments
    def list_loyalty_card_transactions1_with_http_info(self, campaign_id : Annotated[StrictStr, Field(..., description="A unique identifier of the loyalty campaign containing the voucher whose transactions you would like to return.")], member_id : Annotated[StrictStr, Field(..., description="A unique code identifying the loyalty card that you are looking to retrieve transaction data for.")], limit : Annotated[Optional[conint(strict=True, le=100, ge=1)], Field(description="A limit on the number of objects to be returned. Limit can range between 1 and 100 items.")] = None, page : Annotated[Optional[conint(strict=True, le=100)], Field(description="Which page of results to return.")] = None, **kwargs) -> ApiResponse:  # noqa: E501
        """List Loyalty Card Transactions  # noqa: E501

        Retrieve transaction data related to point movements for a specific loyalty card.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.list_loyalty_card_transactions1_with_http_info(campaign_id, member_id, limit, page, async_req=True)
        >>> result = thread.get()

        :param campaign_id: A unique identifier of the loyalty campaign containing the voucher whose transactions you would like to return. (required)
        :type campaign_id: str
        :param member_id: A unique code identifying the loyalty card that you are looking to retrieve transaction data for. (required)
        :type member_id: str
        :param limit: A limit on the number of objects to be returned. Limit can range between 1 and 100 items.
        :type limit: int
        :param page: Which page of results to return.
        :type page: int
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(LoyaltiesMembersTransactionsListResponseBody, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            'campaign_id',
            'member_id',
            'limit',
            'page'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method list_loyalty_card_transactions1" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}
        if _params['campaign_id']:
            _path_params['campaignId'] = _params['campaign_id']

        if _params['member_id']:
            _path_params['memberId'] = _params['member_id']


        # process the query parameters
        _query_params = []
        if _params.get('limit') is not None:  # noqa: E501
            _query_params.append(('limit', _params['limit']))

        if _params.get('page') is not None:  # noqa: E501
            _query_params.append(('page', _params['page']))

        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # authentication setting
        _auth_settings = ['X-App-Id', 'X-App-Token']  # noqa: E501

        _response_types_map = {
            '200': "LoyaltiesMembersTransactionsListResponseBody",
        }

        return self.api_client.call_api(
            '/v1/loyalties/{campaignId}/members/{memberId}/transactions', 'GET',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_arguments
    def list_loyalty_tier_earning_rules(self, campaign_id : Annotated[StrictStr, Field(..., description="Unique campaign ID or name.")], loyalty_tier_id : Annotated[StrictStr, Field(..., description="Unique loyalty tier ID.")], limit : Annotated[Optional[conint(strict=True, le=100, ge=1)], Field(description="A limit on the number of objects to be returned. Limit can range between 1 and 100 items.")] = None, page : Annotated[Optional[conint(strict=True, le=100)], Field(description="Which page of results to return.")] = None, **kwargs) -> LoyaltiesTiersEarningRulesListResponseBody:  # noqa: E501
        """List Loyalty Tier Earning Rules  # noqa: E501

        Retrieve available earning rules for a given tier and the calculation method for earning points.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.list_loyalty_tier_earning_rules(campaign_id, loyalty_tier_id, limit, page, async_req=True)
        >>> result = thread.get()

        :param campaign_id: Unique campaign ID or name. (required)
        :type campaign_id: str
        :param loyalty_tier_id: Unique loyalty tier ID. (required)
        :type loyalty_tier_id: str
        :param limit: A limit on the number of objects to be returned. Limit can range between 1 and 100 items.
        :type limit: int
        :param page: Which page of results to return.
        :type page: int
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request.
               If one number provided, it will be total request
               timeout. It can also be a pair (tuple) of
               (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: LoyaltiesTiersEarningRulesListResponseBody
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            message = "Error! Please call the list_loyalty_tier_earning_rules_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"  # noqa: E501
            raise ValueError(message)
        return self.list_loyalty_tier_earning_rules_with_http_info(campaign_id, loyalty_tier_id, limit, page, **kwargs)  # noqa: E501

    @validate_arguments
    def list_loyalty_tier_earning_rules_with_http_info(self, campaign_id : Annotated[StrictStr, Field(..., description="Unique campaign ID or name.")], loyalty_tier_id : Annotated[StrictStr, Field(..., description="Unique loyalty tier ID.")], limit : Annotated[Optional[conint(strict=True, le=100, ge=1)], Field(description="A limit on the number of objects to be returned. Limit can range between 1 and 100 items.")] = None, page : Annotated[Optional[conint(strict=True, le=100)], Field(description="Which page of results to return.")] = None, **kwargs) -> ApiResponse:  # noqa: E501
        """List Loyalty Tier Earning Rules  # noqa: E501

        Retrieve available earning rules for a given tier and the calculation method for earning points.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.list_loyalty_tier_earning_rules_with_http_info(campaign_id, loyalty_tier_id, limit, page, async_req=True)
        >>> result = thread.get()

        :param campaign_id: Unique campaign ID or name. (required)
        :type campaign_id: str
        :param loyalty_tier_id: Unique loyalty tier ID. (required)
        :type loyalty_tier_id: str
        :param limit: A limit on the number of objects to be returned. Limit can range between 1 and 100 items.
        :type limit: int
        :param page: Which page of results to return.
        :type page: int
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(LoyaltiesTiersEarningRulesListResponseBody, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            'campaign_id',
            'loyalty_tier_id',
            'limit',
            'page'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method list_loyalty_tier_earning_rules" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}
        if _params['campaign_id']:
            _path_params['campaignId'] = _params['campaign_id']

        if _params['loyalty_tier_id']:
            _path_params['loyaltyTierId'] = _params['loyalty_tier_id']


        # process the query parameters
        _query_params = []
        if _params.get('limit') is not None:  # noqa: E501
            _query_params.append(('limit', _params['limit']))

        if _params.get('page') is not None:  # noqa: E501
            _query_params.append(('page', _params['page']))

        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # authentication setting
        _auth_settings = ['X-App-Id', 'X-App-Token']  # noqa: E501

        _response_types_map = {
            '200': "LoyaltiesTiersEarningRulesListResponseBody",
        }

        return self.api_client.call_api(
            '/v1/loyalties/{campaignId}/tiers/{loyaltyTierId}/earning-rules', 'GET',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_arguments
    def list_loyalty_tier_rewards(self, campaign_id : Annotated[StrictStr, Field(..., description="Unique campaign ID or name.")], loyalty_tier_id : Annotated[StrictStr, Field(..., description="Unique loyalty tier ID.")], **kwargs) -> LoyaltiesTiersRewardsListResponseBody:  # noqa: E501
        """List Loyalty Tier Rewards  # noqa: E501

        Get available rewards for a given tier.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.list_loyalty_tier_rewards(campaign_id, loyalty_tier_id, async_req=True)
        >>> result = thread.get()

        :param campaign_id: Unique campaign ID or name. (required)
        :type campaign_id: str
        :param loyalty_tier_id: Unique loyalty tier ID. (required)
        :type loyalty_tier_id: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request.
               If one number provided, it will be total request
               timeout. It can also be a pair (tuple) of
               (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: LoyaltiesTiersRewardsListResponseBody
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            message = "Error! Please call the list_loyalty_tier_rewards_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"  # noqa: E501
            raise ValueError(message)
        return self.list_loyalty_tier_rewards_with_http_info(campaign_id, loyalty_tier_id, **kwargs)  # noqa: E501

    @validate_arguments
    def list_loyalty_tier_rewards_with_http_info(self, campaign_id : Annotated[StrictStr, Field(..., description="Unique campaign ID or name.")], loyalty_tier_id : Annotated[StrictStr, Field(..., description="Unique loyalty tier ID.")], **kwargs) -> ApiResponse:  # noqa: E501
        """List Loyalty Tier Rewards  # noqa: E501

        Get available rewards for a given tier.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.list_loyalty_tier_rewards_with_http_info(campaign_id, loyalty_tier_id, async_req=True)
        >>> result = thread.get()

        :param campaign_id: Unique campaign ID or name. (required)
        :type campaign_id: str
        :param loyalty_tier_id: Unique loyalty tier ID. (required)
        :type loyalty_tier_id: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(LoyaltiesTiersRewardsListResponseBody, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            'campaign_id',
            'loyalty_tier_id'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method list_loyalty_tier_rewards" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}
        if _params['campaign_id']:
            _path_params['campaignId'] = _params['campaign_id']

        if _params['loyalty_tier_id']:
            _path_params['loyaltyTierId'] = _params['loyalty_tier_id']


        # process the query parameters
        _query_params = []
        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # authentication setting
        _auth_settings = ['X-App-Id', 'X-App-Token']  # noqa: E501

        _response_types_map = {
            '200': "LoyaltiesTiersRewardsListResponseBody",
        }

        return self.api_client.call_api(
            '/v1/loyalties/{campaignId}/tiers/{loyaltyTierId}/rewards', 'GET',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_arguments
    def list_loyalty_tiers(self, campaign_id : Annotated[StrictStr, Field(..., description="Unique loyalty campaign ID or name.")], limit : Annotated[Optional[conint(strict=True, le=100, ge=1)], Field(description="A limit on the number of objects to be returned. Limit can range between 1 and 100 items.")] = None, order : Annotated[Optional[ParameterOrderListLoyaltyTiers], Field(description="Sorts the results using one of the filtering options, where the dash - preceding a sorting option means sorting in a descending order.")] = None, **kwargs) -> LoyaltiesTiersListResponseBody:  # noqa: E501
        """List Loyalty Tiers  # noqa: E501

        Retrieve a list of loyalty tiers which were added to the loyalty program.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.list_loyalty_tiers(campaign_id, limit, order, async_req=True)
        >>> result = thread.get()

        :param campaign_id: Unique loyalty campaign ID or name. (required)
        :type campaign_id: str
        :param limit: A limit on the number of objects to be returned. Limit can range between 1 and 100 items.
        :type limit: int
        :param order: Sorts the results using one of the filtering options, where the dash - preceding a sorting option means sorting in a descending order.
        :type order: ParameterOrderListLoyaltyTiers
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request.
               If one number provided, it will be total request
               timeout. It can also be a pair (tuple) of
               (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: LoyaltiesTiersListResponseBody
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            message = "Error! Please call the list_loyalty_tiers_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"  # noqa: E501
            raise ValueError(message)
        return self.list_loyalty_tiers_with_http_info(campaign_id, limit, order, **kwargs)  # noqa: E501

    @validate_arguments
    def list_loyalty_tiers_with_http_info(self, campaign_id : Annotated[StrictStr, Field(..., description="Unique loyalty campaign ID or name.")], limit : Annotated[Optional[conint(strict=True, le=100, ge=1)], Field(description="A limit on the number of objects to be returned. Limit can range between 1 and 100 items.")] = None, order : Annotated[Optional[ParameterOrderListLoyaltyTiers], Field(description="Sorts the results using one of the filtering options, where the dash - preceding a sorting option means sorting in a descending order.")] = None, **kwargs) -> ApiResponse:  # noqa: E501
        """List Loyalty Tiers  # noqa: E501

        Retrieve a list of loyalty tiers which were added to the loyalty program.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.list_loyalty_tiers_with_http_info(campaign_id, limit, order, async_req=True)
        >>> result = thread.get()

        :param campaign_id: Unique loyalty campaign ID or name. (required)
        :type campaign_id: str
        :param limit: A limit on the number of objects to be returned. Limit can range between 1 and 100 items.
        :type limit: int
        :param order: Sorts the results using one of the filtering options, where the dash - preceding a sorting option means sorting in a descending order.
        :type order: ParameterOrderListLoyaltyTiers
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(LoyaltiesTiersListResponseBody, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            'campaign_id',
            'limit',
            'order'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method list_loyalty_tiers" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}
        if _params['campaign_id']:
            _path_params['campaignId'] = _params['campaign_id']


        # process the query parameters
        _query_params = []
        if _params.get('limit') is not None:  # noqa: E501
            _query_params.append(('limit', _params['limit']))

        if _params.get('order') is not None:  # noqa: E501
            _query_params.append(('order', _params['order'].value))

        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # authentication setting
        _auth_settings = ['X-App-Id', 'X-App-Token']  # noqa: E501

        _response_types_map = {
            '200': "LoyaltiesTiersListResponseBody",
        }

        return self.api_client.call_api(
            '/v1/loyalties/{campaignId}/tiers', 'GET',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_arguments
    def list_member_loyalty_tier(self, member_id : Annotated[StrictStr, Field(..., description="Unique loyalty card assigned to a particular customer.")], **kwargs) -> LoyaltiesMembersTiersListResponseBody:  # noqa: E501
        """List Member's Loyalty Tiers  # noqa: E501

        Retrieve member tiers using the loyalty card ID.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.list_member_loyalty_tier(member_id, async_req=True)
        >>> result = thread.get()

        :param member_id: Unique loyalty card assigned to a particular customer. (required)
        :type member_id: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request.
               If one number provided, it will be total request
               timeout. It can also be a pair (tuple) of
               (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: LoyaltiesMembersTiersListResponseBody
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            message = "Error! Please call the list_member_loyalty_tier_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"  # noqa: E501
            raise ValueError(message)
        return self.list_member_loyalty_tier_with_http_info(member_id, **kwargs)  # noqa: E501

    @validate_arguments
    def list_member_loyalty_tier_with_http_info(self, member_id : Annotated[StrictStr, Field(..., description="Unique loyalty card assigned to a particular customer.")], **kwargs) -> ApiResponse:  # noqa: E501
        """List Member's Loyalty Tiers  # noqa: E501

        Retrieve member tiers using the loyalty card ID.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.list_member_loyalty_tier_with_http_info(member_id, async_req=True)
        >>> result = thread.get()

        :param member_id: Unique loyalty card assigned to a particular customer. (required)
        :type member_id: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(LoyaltiesMembersTiersListResponseBody, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            'member_id'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method list_member_loyalty_tier" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}
        if _params['member_id']:
            _path_params['memberId'] = _params['member_id']


        # process the query parameters
        _query_params = []
        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # authentication setting
        _auth_settings = ['X-App-Id', 'X-App-Token']  # noqa: E501

        _response_types_map = {
            '200': "LoyaltiesMembersTiersListResponseBody",
        }

        return self.api_client.call_api(
            '/v1/loyalties/members/{memberId}/tiers', 'GET',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_arguments
    def list_member_rewards(self, member_id : Annotated[StrictStr, Field(..., description="Unique loyalty card assigned to a particular customer.")], affordable_only : Annotated[Optional[StrictBool], Field(description="Limit the results to rewards that the customer can actually afford (only rewards whose price in points is not higher than the loyalty points balance on a loyalty card). Set this flag to `true` to return rewards which the customer can actually afford.")] = None, **kwargs) -> LoyaltiesMembersRewardsListResponseBody:  # noqa: E501
        """List Member Rewards  # noqa: E501

        Retrieves the list of rewards that the given customer (identified by `member_id`, which is a loyalty card assigned to a particular customer) **can get in exchange for loyalty points**.    You can use the `affordable_only` parameter to limit the results to rewards that the customer can actually afford (only rewards whose price in points is not higher than the loyalty points balance on a loyalty card).    Please note that rewards that are disabled (i.e. set to `Not Available` in the Dashboard) for a given loyalty tier reward mapping will not be returned in this endpoint.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.list_member_rewards(member_id, affordable_only, async_req=True)
        >>> result = thread.get()

        :param member_id: Unique loyalty card assigned to a particular customer. (required)
        :type member_id: str
        :param affordable_only: Limit the results to rewards that the customer can actually afford (only rewards whose price in points is not higher than the loyalty points balance on a loyalty card). Set this flag to `true` to return rewards which the customer can actually afford.
        :type affordable_only: bool
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request.
               If one number provided, it will be total request
               timeout. It can also be a pair (tuple) of
               (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: LoyaltiesMembersRewardsListResponseBody
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            message = "Error! Please call the list_member_rewards_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"  # noqa: E501
            raise ValueError(message)
        return self.list_member_rewards_with_http_info(member_id, affordable_only, **kwargs)  # noqa: E501

    @validate_arguments
    def list_member_rewards_with_http_info(self, member_id : Annotated[StrictStr, Field(..., description="Unique loyalty card assigned to a particular customer.")], affordable_only : Annotated[Optional[StrictBool], Field(description="Limit the results to rewards that the customer can actually afford (only rewards whose price in points is not higher than the loyalty points balance on a loyalty card). Set this flag to `true` to return rewards which the customer can actually afford.")] = None, **kwargs) -> ApiResponse:  # noqa: E501
        """List Member Rewards  # noqa: E501

        Retrieves the list of rewards that the given customer (identified by `member_id`, which is a loyalty card assigned to a particular customer) **can get in exchange for loyalty points**.    You can use the `affordable_only` parameter to limit the results to rewards that the customer can actually afford (only rewards whose price in points is not higher than the loyalty points balance on a loyalty card).    Please note that rewards that are disabled (i.e. set to `Not Available` in the Dashboard) for a given loyalty tier reward mapping will not be returned in this endpoint.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.list_member_rewards_with_http_info(member_id, affordable_only, async_req=True)
        >>> result = thread.get()

        :param member_id: Unique loyalty card assigned to a particular customer. (required)
        :type member_id: str
        :param affordable_only: Limit the results to rewards that the customer can actually afford (only rewards whose price in points is not higher than the loyalty points balance on a loyalty card). Set this flag to `true` to return rewards which the customer can actually afford.
        :type affordable_only: bool
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(LoyaltiesMembersRewardsListResponseBody, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            'member_id',
            'affordable_only'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method list_member_rewards" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}
        if _params['member_id']:
            _path_params['memberId'] = _params['member_id']


        # process the query parameters
        _query_params = []
        if _params.get('affordable_only') is not None:  # noqa: E501
            _query_params.append(('affordable_only', _params['affordable_only']))

        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # authentication setting
        _auth_settings = ['X-App-Id', 'X-App-Token']  # noqa: E501

        _response_types_map = {
            '200': "LoyaltiesMembersRewardsListResponseBody",
        }

        return self.api_client.call_api(
            '/v1/loyalties/members/{memberId}/rewards', 'GET',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_arguments
    def list_points_expiration(self, campaign_id : Annotated[StrictStr, Field(..., description="The campaign ID or name of the loyalty campaign. You can either pass the campaign ID, which was assigned by Voucherify, or the `name` of the campaign as the path parameter value, e.g., `Loyalty%20Campaign`. ")], member_id : Annotated[StrictStr, Field(..., description="Loyalty card code.")], limit : Annotated[Optional[conint(strict=True, le=100, ge=1)], Field(description="A limit on the number of objects to be returned. Limit can range between 1 and 100 items.")] = None, page : Annotated[Optional[conint(strict=True, le=100)], Field(description="Which page of results to return.")] = None, **kwargs) -> LoyaltiesMembersPointsExpirationListResponseBody:  # noqa: E501
        """Get Points Expiration  # noqa: E501

        Retrieve loyalty point expiration buckets for a given loyalty card. Expired point buckets are not returned in this endpoint. You can use the [Exports API](ref:create-export) to retrieve a list of both `ACTIVE` and `EXPIRED` point buckets.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.list_points_expiration(campaign_id, member_id, limit, page, async_req=True)
        >>> result = thread.get()

        :param campaign_id: The campaign ID or name of the loyalty campaign. You can either pass the campaign ID, which was assigned by Voucherify, or the `name` of the campaign as the path parameter value, e.g., `Loyalty%20Campaign`.  (required)
        :type campaign_id: str
        :param member_id: Loyalty card code. (required)
        :type member_id: str
        :param limit: A limit on the number of objects to be returned. Limit can range between 1 and 100 items.
        :type limit: int
        :param page: Which page of results to return.
        :type page: int
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request.
               If one number provided, it will be total request
               timeout. It can also be a pair (tuple) of
               (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: LoyaltiesMembersPointsExpirationListResponseBody
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            message = "Error! Please call the list_points_expiration_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"  # noqa: E501
            raise ValueError(message)
        return self.list_points_expiration_with_http_info(campaign_id, member_id, limit, page, **kwargs)  # noqa: E501

    @validate_arguments
    def list_points_expiration_with_http_info(self, campaign_id : Annotated[StrictStr, Field(..., description="The campaign ID or name of the loyalty campaign. You can either pass the campaign ID, which was assigned by Voucherify, or the `name` of the campaign as the path parameter value, e.g., `Loyalty%20Campaign`. ")], member_id : Annotated[StrictStr, Field(..., description="Loyalty card code.")], limit : Annotated[Optional[conint(strict=True, le=100, ge=1)], Field(description="A limit on the number of objects to be returned. Limit can range between 1 and 100 items.")] = None, page : Annotated[Optional[conint(strict=True, le=100)], Field(description="Which page of results to return.")] = None, **kwargs) -> ApiResponse:  # noqa: E501
        """Get Points Expiration  # noqa: E501

        Retrieve loyalty point expiration buckets for a given loyalty card. Expired point buckets are not returned in this endpoint. You can use the [Exports API](ref:create-export) to retrieve a list of both `ACTIVE` and `EXPIRED` point buckets.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.list_points_expiration_with_http_info(campaign_id, member_id, limit, page, async_req=True)
        >>> result = thread.get()

        :param campaign_id: The campaign ID or name of the loyalty campaign. You can either pass the campaign ID, which was assigned by Voucherify, or the `name` of the campaign as the path parameter value, e.g., `Loyalty%20Campaign`.  (required)
        :type campaign_id: str
        :param member_id: Loyalty card code. (required)
        :type member_id: str
        :param limit: A limit on the number of objects to be returned. Limit can range between 1 and 100 items.
        :type limit: int
        :param page: Which page of results to return.
        :type page: int
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(LoyaltiesMembersPointsExpirationListResponseBody, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            'campaign_id',
            'member_id',
            'limit',
            'page'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method list_points_expiration" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}
        if _params['campaign_id']:
            _path_params['campaignId'] = _params['campaign_id']

        if _params['member_id']:
            _path_params['memberId'] = _params['member_id']


        # process the query parameters
        _query_params = []
        if _params.get('limit') is not None:  # noqa: E501
            _query_params.append(('limit', _params['limit']))

        if _params.get('page') is not None:  # noqa: E501
            _query_params.append(('page', _params['page']))

        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # authentication setting
        _auth_settings = ['X-App-Id', 'X-App-Token']  # noqa: E501

        _response_types_map = {
            '200': "LoyaltiesMembersPointsExpirationListResponseBody",
        }

        return self.api_client.call_api(
            '/v1/loyalties/{campaignId}/members/{memberId}/points-expiration', 'GET',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_arguments
    def redeem_reward(self, member_id : Annotated[StrictStr, Field(..., description="Unique loyalty card assigned to a particular customer.")], loyalties_members_redemption_redeem_request_body : Annotated[Optional[LoyaltiesMembersRedemptionRedeemRequestBody], Field(description="Specify the reward to be redeemed. In case of a pay with points reward, specify the order and the number of points to be applied to the order. Please note that if you do not specify the amount of points, the application will default to applying the number of points to pay for the remainder of the order. If the limit of available points on the card is reached, then only the available points on the card will be applied to the order.")] = None, **kwargs) -> LoyaltiesMembersRedemptionRedeemResponseBody:  # noqa: E501
        """Redeem Reward  # noqa: E501

        <!-- theme: info --> > 📘 Alternative endpoint > > This endpoint is an alternative to this <!-- [endpoint](OpenAPI.json/paths/~1loyalties~1{campaignId}~1members~1{memberId}~1redemption) -->[endpoint](ref:redeem-reward-1). The URL was re-designed to allow you to redeem a reward without having to provide the `campaignId` as a path parameter.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.redeem_reward(member_id, loyalties_members_redemption_redeem_request_body, async_req=True)
        >>> result = thread.get()

        :param member_id: Unique loyalty card assigned to a particular customer. (required)
        :type member_id: str
        :param loyalties_members_redemption_redeem_request_body: Specify the reward to be redeemed. In case of a pay with points reward, specify the order and the number of points to be applied to the order. Please note that if you do not specify the amount of points, the application will default to applying the number of points to pay for the remainder of the order. If the limit of available points on the card is reached, then only the available points on the card will be applied to the order.
        :type loyalties_members_redemption_redeem_request_body: LoyaltiesMembersRedemptionRedeemRequestBody
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request.
               If one number provided, it will be total request
               timeout. It can also be a pair (tuple) of
               (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: LoyaltiesMembersRedemptionRedeemResponseBody
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            message = "Error! Please call the redeem_reward_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"  # noqa: E501
            raise ValueError(message)
        return self.redeem_reward_with_http_info(member_id, loyalties_members_redemption_redeem_request_body, **kwargs)  # noqa: E501

    @validate_arguments
    def redeem_reward_with_http_info(self, member_id : Annotated[StrictStr, Field(..., description="Unique loyalty card assigned to a particular customer.")], loyalties_members_redemption_redeem_request_body : Annotated[Optional[LoyaltiesMembersRedemptionRedeemRequestBody], Field(description="Specify the reward to be redeemed. In case of a pay with points reward, specify the order and the number of points to be applied to the order. Please note that if you do not specify the amount of points, the application will default to applying the number of points to pay for the remainder of the order. If the limit of available points on the card is reached, then only the available points on the card will be applied to the order.")] = None, **kwargs) -> ApiResponse:  # noqa: E501
        """Redeem Reward  # noqa: E501

        <!-- theme: info --> > 📘 Alternative endpoint > > This endpoint is an alternative to this <!-- [endpoint](OpenAPI.json/paths/~1loyalties~1{campaignId}~1members~1{memberId}~1redemption) -->[endpoint](ref:redeem-reward-1). The URL was re-designed to allow you to redeem a reward without having to provide the `campaignId` as a path parameter.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.redeem_reward_with_http_info(member_id, loyalties_members_redemption_redeem_request_body, async_req=True)
        >>> result = thread.get()

        :param member_id: Unique loyalty card assigned to a particular customer. (required)
        :type member_id: str
        :param loyalties_members_redemption_redeem_request_body: Specify the reward to be redeemed. In case of a pay with points reward, specify the order and the number of points to be applied to the order. Please note that if you do not specify the amount of points, the application will default to applying the number of points to pay for the remainder of the order. If the limit of available points on the card is reached, then only the available points on the card will be applied to the order.
        :type loyalties_members_redemption_redeem_request_body: LoyaltiesMembersRedemptionRedeemRequestBody
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(LoyaltiesMembersRedemptionRedeemResponseBody, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            'member_id',
            'loyalties_members_redemption_redeem_request_body'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method redeem_reward" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}
        if _params['member_id']:
            _path_params['memberId'] = _params['member_id']


        # process the query parameters
        _query_params = []
        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        if _params['loyalties_members_redemption_redeem_request_body'] is not None:
            _body_params = _params['loyalties_members_redemption_redeem_request_body']

        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # set the HTTP header `Content-Type`
        _content_types_list = _params.get('_content_type',
            self.api_client.select_header_content_type(
                ['application/json']))
        if _content_types_list:
                _header_params['Content-Type'] = _content_types_list

        # authentication setting
        _auth_settings = ['X-App-Id', 'X-App-Token']  # noqa: E501

        _response_types_map = {
            '200': "LoyaltiesMembersRedemptionRedeemResponseBody",
        }

        return self.api_client.call_api(
            '/v1/loyalties/members/{memberId}/redemption', 'POST',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_arguments
    def redeem_reward1(self, campaign_id : Annotated[StrictStr, Field(..., description="Unique campaign ID.")], member_id : Annotated[StrictStr, Field(..., description="A code that identifies the loyalty card.")], loyalties_members_redemption_redeem_request_body : Annotated[Optional[LoyaltiesMembersRedemptionRedeemRequestBody], Field(description="Specify the reward to be redeemed. In case of a pay with points reward, specify the order and the number of points to be applied to the order. Please note that if you do not specify the amount of points, the application will default to applying the number of points to pay for the remainder of the order. If the limit of available points on the card is reached, then only the available points on the card will be applied to the order.")] = None, **kwargs) -> LoyaltiesMembersRedemptionRedeemResponseBody:  # noqa: E501
        """Redeem Reward  # noqa: E501

        Exchange points from a loyalty card for a specified reward. This API method returns an assigned award in the response. It means that if a requesting customer gets a coupon code with a discount for the next order, that discount code will be visible in response as part of the reward object definition.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.redeem_reward1(campaign_id, member_id, loyalties_members_redemption_redeem_request_body, async_req=True)
        >>> result = thread.get()

        :param campaign_id: Unique campaign ID. (required)
        :type campaign_id: str
        :param member_id: A code that identifies the loyalty card. (required)
        :type member_id: str
        :param loyalties_members_redemption_redeem_request_body: Specify the reward to be redeemed. In case of a pay with points reward, specify the order and the number of points to be applied to the order. Please note that if you do not specify the amount of points, the application will default to applying the number of points to pay for the remainder of the order. If the limit of available points on the card is reached, then only the available points on the card will be applied to the order.
        :type loyalties_members_redemption_redeem_request_body: LoyaltiesMembersRedemptionRedeemRequestBody
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request.
               If one number provided, it will be total request
               timeout. It can also be a pair (tuple) of
               (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: LoyaltiesMembersRedemptionRedeemResponseBody
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            message = "Error! Please call the redeem_reward1_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"  # noqa: E501
            raise ValueError(message)
        return self.redeem_reward1_with_http_info(campaign_id, member_id, loyalties_members_redemption_redeem_request_body, **kwargs)  # noqa: E501

    @validate_arguments
    def redeem_reward1_with_http_info(self, campaign_id : Annotated[StrictStr, Field(..., description="Unique campaign ID.")], member_id : Annotated[StrictStr, Field(..., description="A code that identifies the loyalty card.")], loyalties_members_redemption_redeem_request_body : Annotated[Optional[LoyaltiesMembersRedemptionRedeemRequestBody], Field(description="Specify the reward to be redeemed. In case of a pay with points reward, specify the order and the number of points to be applied to the order. Please note that if you do not specify the amount of points, the application will default to applying the number of points to pay for the remainder of the order. If the limit of available points on the card is reached, then only the available points on the card will be applied to the order.")] = None, **kwargs) -> ApiResponse:  # noqa: E501
        """Redeem Reward  # noqa: E501

        Exchange points from a loyalty card for a specified reward. This API method returns an assigned award in the response. It means that if a requesting customer gets a coupon code with a discount for the next order, that discount code will be visible in response as part of the reward object definition.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.redeem_reward1_with_http_info(campaign_id, member_id, loyalties_members_redemption_redeem_request_body, async_req=True)
        >>> result = thread.get()

        :param campaign_id: Unique campaign ID. (required)
        :type campaign_id: str
        :param member_id: A code that identifies the loyalty card. (required)
        :type member_id: str
        :param loyalties_members_redemption_redeem_request_body: Specify the reward to be redeemed. In case of a pay with points reward, specify the order and the number of points to be applied to the order. Please note that if you do not specify the amount of points, the application will default to applying the number of points to pay for the remainder of the order. If the limit of available points on the card is reached, then only the available points on the card will be applied to the order.
        :type loyalties_members_redemption_redeem_request_body: LoyaltiesMembersRedemptionRedeemRequestBody
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(LoyaltiesMembersRedemptionRedeemResponseBody, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            'campaign_id',
            'member_id',
            'loyalties_members_redemption_redeem_request_body'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method redeem_reward1" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}
        if _params['campaign_id']:
            _path_params['campaignId'] = _params['campaign_id']

        if _params['member_id']:
            _path_params['memberId'] = _params['member_id']


        # process the query parameters
        _query_params = []
        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        if _params['loyalties_members_redemption_redeem_request_body'] is not None:
            _body_params = _params['loyalties_members_redemption_redeem_request_body']

        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # set the HTTP header `Content-Type`
        _content_types_list = _params.get('_content_type',
            self.api_client.select_header_content_type(
                ['application/json']))
        if _content_types_list:
                _header_params['Content-Type'] = _content_types_list

        # authentication setting
        _auth_settings = ['X-App-Id', 'X-App-Token']  # noqa: E501

        _response_types_map = {
            '200': "LoyaltiesMembersRedemptionRedeemResponseBody",
        }

        return self.api_client.call_api(
            '/v1/loyalties/{campaignId}/members/{memberId}/redemption', 'POST',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_arguments
    def transfer_points(self, campaign_id : Annotated[StrictStr, Field(..., description="A unique identifier of the loyalty campaign containing the voucher to which the loyalty points will be sent (destination).")], member_id : Annotated[StrictStr, Field(..., description="A unique code identifying the loyalty card to which the user wants to transfer loyalty points (destination).")], loyalties_transfer_points : Annotated[Optional[conlist(LoyaltiesTransferPoints)], Field(description="Provide the loyalty cards you want the points to be transferred from and the number of points to transfer from each card.")] = None, **kwargs) -> LoyaltiesMembersTransfersCreateResponseBody:  # noqa: E501
        """Transfer Loyalty Points  # noqa: E501

        Transfer points between different loyalty cards. You need to provide the campaign ID and the loyalty card ID you want the points to be transferred to as path parameters in the URL. In the request body, you provide the loyalty cards you want the points to be transferred from and the number of points to transfer from each card.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.transfer_points(campaign_id, member_id, loyalties_transfer_points, async_req=True)
        >>> result = thread.get()

        :param campaign_id: A unique identifier of the loyalty campaign containing the voucher to which the loyalty points will be sent (destination). (required)
        :type campaign_id: str
        :param member_id: A unique code identifying the loyalty card to which the user wants to transfer loyalty points (destination). (required)
        :type member_id: str
        :param loyalties_transfer_points: Provide the loyalty cards you want the points to be transferred from and the number of points to transfer from each card.
        :type loyalties_transfer_points: List[LoyaltiesTransferPoints]
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request.
               If one number provided, it will be total request
               timeout. It can also be a pair (tuple) of
               (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: LoyaltiesMembersTransfersCreateResponseBody
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            message = "Error! Please call the transfer_points_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"  # noqa: E501
            raise ValueError(message)
        return self.transfer_points_with_http_info(campaign_id, member_id, loyalties_transfer_points, **kwargs)  # noqa: E501

    @validate_arguments
    def transfer_points_with_http_info(self, campaign_id : Annotated[StrictStr, Field(..., description="A unique identifier of the loyalty campaign containing the voucher to which the loyalty points will be sent (destination).")], member_id : Annotated[StrictStr, Field(..., description="A unique code identifying the loyalty card to which the user wants to transfer loyalty points (destination).")], loyalties_transfer_points : Annotated[Optional[conlist(LoyaltiesTransferPoints)], Field(description="Provide the loyalty cards you want the points to be transferred from and the number of points to transfer from each card.")] = None, **kwargs) -> ApiResponse:  # noqa: E501
        """Transfer Loyalty Points  # noqa: E501

        Transfer points between different loyalty cards. You need to provide the campaign ID and the loyalty card ID you want the points to be transferred to as path parameters in the URL. In the request body, you provide the loyalty cards you want the points to be transferred from and the number of points to transfer from each card.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.transfer_points_with_http_info(campaign_id, member_id, loyalties_transfer_points, async_req=True)
        >>> result = thread.get()

        :param campaign_id: A unique identifier of the loyalty campaign containing the voucher to which the loyalty points will be sent (destination). (required)
        :type campaign_id: str
        :param member_id: A unique code identifying the loyalty card to which the user wants to transfer loyalty points (destination). (required)
        :type member_id: str
        :param loyalties_transfer_points: Provide the loyalty cards you want the points to be transferred from and the number of points to transfer from each card.
        :type loyalties_transfer_points: List[LoyaltiesTransferPoints]
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(LoyaltiesMembersTransfersCreateResponseBody, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            'campaign_id',
            'member_id',
            'loyalties_transfer_points'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method transfer_points" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}
        if _params['campaign_id']:
            _path_params['campaignId'] = _params['campaign_id']

        if _params['member_id']:
            _path_params['memberId'] = _params['member_id']


        # process the query parameters
        _query_params = []
        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        if _params['loyalties_transfer_points'] is not None:
            _body_params = _params['loyalties_transfer_points']

        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # set the HTTP header `Content-Type`
        _content_types_list = _params.get('_content_type',
            self.api_client.select_header_content_type(
                ['application/json']))
        if _content_types_list:
                _header_params['Content-Type'] = _content_types_list

        # authentication setting
        _auth_settings = ['X-App-Id', 'X-App-Token']  # noqa: E501

        _response_types_map = {
            '200': "LoyaltiesMembersTransfersCreateResponseBody",
        }

        return self.api_client.call_api(
            '/v1/loyalties/{campaignId}/members/{memberId}/transfers', 'POST',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_arguments
    def update_loyalty_card_balance(self, member_id : Annotated[StrictStr, Field(..., description="Unique loyalty card assigned to a particular customer.")], loyalties_members_balance_update_request_body : Annotated[Optional[LoyaltiesMembersBalanceUpdateRequestBody], Field(description="Specify the point adjustment along with the expiration mechanism.")] = None, **kwargs) -> LoyaltiesMembersBalanceUpdateResponseBody:  # noqa: E501
        """Add or Remove Loyalty Card Balance  # noqa: E501

        This method gives adds or removes balance to an existing loyalty card. The removal of points will consume the points that expire the soonest.   <!-- theme: info --> > 📘 Alternative endpoint > This endpoint is an alternative to this <!-- [endpoint](OpenAPI.json/paths/~1loyalties~1{campaignId}~1members~1{memberId}~1balance) -->[endpoint](ref:update-loyalty-card-balance-1). The URL was re-designed to allow you to add or remove loyalty card balance without having to provide the `campaignId` as a path parameter.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.update_loyalty_card_balance(member_id, loyalties_members_balance_update_request_body, async_req=True)
        >>> result = thread.get()

        :param member_id: Unique loyalty card assigned to a particular customer. (required)
        :type member_id: str
        :param loyalties_members_balance_update_request_body: Specify the point adjustment along with the expiration mechanism.
        :type loyalties_members_balance_update_request_body: LoyaltiesMembersBalanceUpdateRequestBody
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request.
               If one number provided, it will be total request
               timeout. It can also be a pair (tuple) of
               (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: LoyaltiesMembersBalanceUpdateResponseBody
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            message = "Error! Please call the update_loyalty_card_balance_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"  # noqa: E501
            raise ValueError(message)
        return self.update_loyalty_card_balance_with_http_info(member_id, loyalties_members_balance_update_request_body, **kwargs)  # noqa: E501

    @validate_arguments
    def update_loyalty_card_balance_with_http_info(self, member_id : Annotated[StrictStr, Field(..., description="Unique loyalty card assigned to a particular customer.")], loyalties_members_balance_update_request_body : Annotated[Optional[LoyaltiesMembersBalanceUpdateRequestBody], Field(description="Specify the point adjustment along with the expiration mechanism.")] = None, **kwargs) -> ApiResponse:  # noqa: E501
        """Add or Remove Loyalty Card Balance  # noqa: E501

        This method gives adds or removes balance to an existing loyalty card. The removal of points will consume the points that expire the soonest.   <!-- theme: info --> > 📘 Alternative endpoint > This endpoint is an alternative to this <!-- [endpoint](OpenAPI.json/paths/~1loyalties~1{campaignId}~1members~1{memberId}~1balance) -->[endpoint](ref:update-loyalty-card-balance-1). The URL was re-designed to allow you to add or remove loyalty card balance without having to provide the `campaignId` as a path parameter.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.update_loyalty_card_balance_with_http_info(member_id, loyalties_members_balance_update_request_body, async_req=True)
        >>> result = thread.get()

        :param member_id: Unique loyalty card assigned to a particular customer. (required)
        :type member_id: str
        :param loyalties_members_balance_update_request_body: Specify the point adjustment along with the expiration mechanism.
        :type loyalties_members_balance_update_request_body: LoyaltiesMembersBalanceUpdateRequestBody
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(LoyaltiesMembersBalanceUpdateResponseBody, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            'member_id',
            'loyalties_members_balance_update_request_body'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method update_loyalty_card_balance" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}
        if _params['member_id']:
            _path_params['memberId'] = _params['member_id']


        # process the query parameters
        _query_params = []
        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        if _params['loyalties_members_balance_update_request_body'] is not None:
            _body_params = _params['loyalties_members_balance_update_request_body']

        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # set the HTTP header `Content-Type`
        _content_types_list = _params.get('_content_type',
            self.api_client.select_header_content_type(
                ['application/json']))
        if _content_types_list:
                _header_params['Content-Type'] = _content_types_list

        # authentication setting
        _auth_settings = ['X-App-Id', 'X-App-Token']  # noqa: E501

        _response_types_map = {
            '200': "LoyaltiesMembersBalanceUpdateResponseBody",
        }

        return self.api_client.call_api(
            '/v1/loyalties/members/{memberId}/balance', 'POST',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_arguments
    def update_loyalty_card_balance1(self, campaign_id : Annotated[StrictStr, Field(..., description="Unique campaign ID.")], member_id : Annotated[StrictStr, Field(..., description="A code that identifies the loyalty card.")], loyalties_members_balance_update_request_body : Annotated[Optional[LoyaltiesMembersBalanceUpdateRequestBody], Field(description="Specify the point adjustment along with the expiration mechanism.")] = None, **kwargs) -> LoyaltiesMembersBalanceUpdateResponseBody:  # noqa: E501
        """Add or Remove Loyalty Card Balance  # noqa: E501

        This method adds or removes balance to an existing loyalty card. The removal of points will consume the points that expire the soonest.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.update_loyalty_card_balance1(campaign_id, member_id, loyalties_members_balance_update_request_body, async_req=True)
        >>> result = thread.get()

        :param campaign_id: Unique campaign ID. (required)
        :type campaign_id: str
        :param member_id: A code that identifies the loyalty card. (required)
        :type member_id: str
        :param loyalties_members_balance_update_request_body: Specify the point adjustment along with the expiration mechanism.
        :type loyalties_members_balance_update_request_body: LoyaltiesMembersBalanceUpdateRequestBody
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request.
               If one number provided, it will be total request
               timeout. It can also be a pair (tuple) of
               (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: LoyaltiesMembersBalanceUpdateResponseBody
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            message = "Error! Please call the update_loyalty_card_balance1_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"  # noqa: E501
            raise ValueError(message)
        return self.update_loyalty_card_balance1_with_http_info(campaign_id, member_id, loyalties_members_balance_update_request_body, **kwargs)  # noqa: E501

    @validate_arguments
    def update_loyalty_card_balance1_with_http_info(self, campaign_id : Annotated[StrictStr, Field(..., description="Unique campaign ID.")], member_id : Annotated[StrictStr, Field(..., description="A code that identifies the loyalty card.")], loyalties_members_balance_update_request_body : Annotated[Optional[LoyaltiesMembersBalanceUpdateRequestBody], Field(description="Specify the point adjustment along with the expiration mechanism.")] = None, **kwargs) -> ApiResponse:  # noqa: E501
        """Add or Remove Loyalty Card Balance  # noqa: E501

        This method adds or removes balance to an existing loyalty card. The removal of points will consume the points that expire the soonest.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.update_loyalty_card_balance1_with_http_info(campaign_id, member_id, loyalties_members_balance_update_request_body, async_req=True)
        >>> result = thread.get()

        :param campaign_id: Unique campaign ID. (required)
        :type campaign_id: str
        :param member_id: A code that identifies the loyalty card. (required)
        :type member_id: str
        :param loyalties_members_balance_update_request_body: Specify the point adjustment along with the expiration mechanism.
        :type loyalties_members_balance_update_request_body: LoyaltiesMembersBalanceUpdateRequestBody
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(LoyaltiesMembersBalanceUpdateResponseBody, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            'campaign_id',
            'member_id',
            'loyalties_members_balance_update_request_body'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method update_loyalty_card_balance1" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}
        if _params['campaign_id']:
            _path_params['campaignId'] = _params['campaign_id']

        if _params['member_id']:
            _path_params['memberId'] = _params['member_id']


        # process the query parameters
        _query_params = []
        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        if _params['loyalties_members_balance_update_request_body'] is not None:
            _body_params = _params['loyalties_members_balance_update_request_body']

        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # set the HTTP header `Content-Type`
        _content_types_list = _params.get('_content_type',
            self.api_client.select_header_content_type(
                ['application/json']))
        if _content_types_list:
                _header_params['Content-Type'] = _content_types_list

        # authentication setting
        _auth_settings = ['X-App-Id', 'X-App-Token']  # noqa: E501

        _response_types_map = {
            '200': "LoyaltiesMembersBalanceUpdateResponseBody",
        }

        return self.api_client.call_api(
            '/v1/loyalties/{campaignId}/members/{memberId}/balance', 'POST',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))
